-- #############################################################################
-- # SECTION 1 : MODÉLISATION DES COMPÉTITIONS ET DE LEUR SPÉCIALISATION       #
-- # ------------------------------------------------------------------------- #
-- # Cette section met en place un modèle de généralisation/spécialisation    #
-- #  où une "Competition" est une entité mère qui se spécialise en  
-- # "League" ou en "Championship", avec des triggers pour garantir une       #
-- # l'intégrité des données.                                          #
-- #############################################################################

-- =============================================================================
-- TABLE 1.1 : COMPETITION (ENTITÉ MÈRE)
-- =============================================================================
CREATE TABLE Competition (
    ID_Competition SERIAL CONSTRAINT PK_Competition PRIMARY KEY,
    --  booléens pour définir le type exact de la compétition.
    IS_League BOOLEAN NOT NULL,
    IS_Championship BOOLEAN NOT NULL,
    Name VARCHAR(55) NOT NULL,
    -- Contrainte de vérification fondamentale (XOR logique).
    -- Elle garantit qu'une compétition est EXCLUSIVEMENT une League OU un Championship.
    CONSTRAINT chk_league_or_championship CHECK (
        (IS_League AND NOT IS_Championship) OR 
        (NOT IS_League AND IS_Championship)
    )
);

-- =============================================================================
-- TABLES 1.2 : LEAGUE ET CHAMPIONSHIP (ENTITÉS FILLES)
-- =============================================================================
CREATE TABLE League (
    -- La clé primaire est aussi une clé étrangère
    ID_Competition INT NOT NULL Constraint PK_League Primary Key,
    Constraint FK_League_Competition Foreign Key(ID_Competition) REFERENCES Competition
);

Create TABLE Championship(
    -- Logique identique pour la spécialisation Championship.
    ID_Competition INT NOT NULL Constraint PK_Championship Primary Key,
    Constraint FK_Championship_Competition Foreign Key(ID_Competition) REFERENCES Competition
);

-- =============================================================================
-- TRIGGER 1.3 : VERROUILLAGE DU TYPE DE COMPÉTITION APRÈS CRÉATION
-- =============================================================================
-- Fonction qui interdit la modification des booléens de type.
CREATE OR REPLACE FUNCTION prevent_competition_type_change()
RETURNS TRIGGER AS $$
BEGIN
    -- Cette règle métier assure la stabilité du modèle : une fois une League créée, elle ne peut pas devenir un Championship.
    -- On compare la nouvelle valeur (NEW) avec l'ancienne (OLD) pour détecter un changement.
    IF (NEW.IS_League <> OLD.IS_League) OR (NEW.IS_Championship <> OLD.IS_Championship) THEN
        RAISE EXCEPTION 'Changement de type de compétition interdit : impossible de convertir League <-> Championship.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Déclencheur qui exécute la fonction avant chaque mise à jour sur la table Competition.
CREATE TRIGGER trg_prevent_competition_type_change
BEFORE UPDATE ON Competition
FOR EACH ROW
EXECUTE FUNCTION prevent_competition_type_change();

-- =============================================================================
-- TRIGGER 1.4 : CONTRÔLE DE COHÉRENCE À L'INSERTION DANS LES TABLES FILLES
-- =============================================================================
--Fonctions utilisées pour valider les insertions dans League et Championship.
-- -----------------------------------------------------------------------------
-- Fonction et Trigger pour la table LEAGUE
-- -----------------------------------------------------------------------------
-- Fonction dédiée à la validation des insertions dans la table League.
CREATE OR REPLACE FUNCTION trg_check_league_type_fn()
RETURNS TRIGGER AS $$
DECLARE
    is_league_type BOOLEAN;
BEGIN
    -- On récupère le type réel de la compétition depuis la table mère.
    SELECT IS_League
    INTO is_league_type
    FROM Competition
    WHERE ID_Competition = NEW.ID_Competition;

    -- On vérifie que la compétition est bien marquée comme étant une League.
    IF is_league_type IS DISTINCT FROM TRUE THEN
        RAISE EXCEPTION 'Erreur : La compétition % doit être de type League pour apparaître dans la table League.',
        NEW.ID_Competition;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Application du trigger dédié sur la table League.
CREATE TRIGGER TRG_CHECK_LEAGUE
BEFORE INSERT OR UPDATE ON League
FOR EACH ROW
EXECUTE FUNCTION trg_check_league_type_fn();

-- -----------------------------------------------------------------------------
-- Fonction et Trigger pour la table CHAMPIONSHIP
-- -----------------------------------------------------------------------------
-- Fonction dédiée à la validation des insertions dans la table Championship.
CREATE OR REPLACE FUNCTION trg_check_championship_type_fn()
RETURNS TRIGGER AS $$
DECLARE
    is_champ_type BOOLEAN;
BEGIN
    -- On récupère le type réel de la compétition depuis la table mère.
    SELECT IS_Championship
    INTO is_champ_type
    FROM Competition
    WHERE ID_Competition = NEW.ID_Competition;

    -- On vérifie que la compétition est bien marquée comme étant un Championship.
    IF is_champ_type IS DISTINCT FROM TRUE THEN
        RAISE EXCEPTION 'Erreur : La compétition % doit être de type Championship pour apparaître dans la table Championship.',
        NEW.ID_Competition;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Application du trigger dédié sur la table Championship.
CREATE TRIGGER TRG_CHECK_Championship
BEFORE INSERT OR UPDATE ON Championship
FOR EACH ROW
EXECUTE FUNCTION trg_check_championship_type_fn();

-- =============================================================================
-- TABLE 1.5 : SEASON
-- =============================================================================
Create Table Season (
    ID_SEASON SERIAL Constraint PK_Season Primary Key,
    Start_Date Date NOT NULL,
    End_Date Date NOT NULL,
    ID_Competition INT,
    -- Assure la cohérence chronologique des dates d'une saison.
    Constraint CKECK_Dates CHECK(Start_Date < End_Date),
    -- Règle métier importante : la clé étrangère pointe vers "League", signifiant que seules les Leagues ont des saisons.
    Constraint FK_Season_League Foreign Key(ID_Competition) REFERENCES League
);

-- #############################################################################
-- # SECTION 2 : GESTION DES JOUEURS (PLAYER) ET DE LEURS NATIONALITÉS         #
-- #############################################################################
Create table Player(
    ID_Player SERIAL Constraint PK_Player Primary Key,
    Name VARCHAR(55) NOT NULL,
    Date_Of_Birth Date NOT NULL,
    Height Decimal(9,2) NOT NULL
);

Create Table Citizenship(
    ID_Player INT NOT NULL,
    Citizenship VARCHAR(55) NOT NULL,
    -- Clé primaire composite pour matérialiser la relation plusieurs-à-plusieurs : un joueur peut avoir plusieurs nationalités.
    Constraint PK_Citizenship Primary Key(ID_Player,Citizenship),
    Constraint FK_Citizenship_Player Foreign Key(ID_Player) REFERENCES PLayer
);

-- #############################################################################
-- # SECTION 3 : MODÉLISATION DES ÉQUIPES (TEAM) ET DE LEUR SPÉCIALISATION     #
-- # Une "Team" se spécialise en "Club" ou en "National_Team".                 #
-- #############################################################################
Create Table Team(
    ID_Team SERIAL Constraint PK_Team Primary Key,
    -- Variables de type booléen pour la spécialisation exclusive.
    IS_Club BOOLEAN NOT NULL,
    IS_National_Team BOOLEAN NOT NULL,
    -- Contrainte XOR garantissant qu'une équipe est SOIT un club, SOIT une équipe nationale.
    CONSTRAINT chk_Club_or_National_Team CHECK (
        (IS_Club AND NOT IS_National_Team) OR 
        (NOT IS_Club AND IS_National_Team))
);

Create Table National_Team(
    ID_National_Team INT Constraint PK_National_Team Primary Key,
    Country VARCHAR(55) NOT NULL,
    Constraint FK_National_Team_Team Foreign Key(ID_National_Team) REFERENCES Team(ID_Team)
);

Create Table Club(
    ID_Club INT Constraint PK_Club Primary Key,
    Name VARCHAR(55) NOT NULL,
    City VARCHAR(55) NOT NULL,
    Constraint FK_Club_Team Foreign Key(ID_Club) REFERENCES Team(ID_Team)
);

-- Trigger pour interdire le changement de type d'une équipe (Club <-> National_Team).
CREATE OR REPLACE FUNCTION prevent_Team_type_change()
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.IS_Club <> OLD.IS_Club) OR (NEW.IS_National_Team <> OLD.IS_National_Team) THEN
        RAISE EXCEPTION 'Changement de type equipe interdit : impossible de convertir Club <-> National Team';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- -----------------------------------------------------------------------------
-- Fonction et Trigger pour la table CLUB
-- -----------------------------------------------------------------------------
-- Fonction dédiée à la validation des insertions dans la table Club.
CREATE OR REPLACE FUNCTION trg_check_club_type_fn()
RETURNS TRIGGER AS $$
DECLARE
    is_club_type BOOLEAN;
BEGIN
    -- On vérifie dans la table mère que l'ID correspond bien à une équipe de type "Club".
    -- La référence à NEW.ID_Club est valide car ce trigger ne s'applique qu'à la table Club.
    SELECT IS_Club
    INTO is_club_type
    FROM Team
    WHERE ID_Team = NEW.ID_Club;
    
    IF is_club_type IS DISTINCT FROM TRUE THEN
        RAISE EXCEPTION 'Erreur : L''équipe (ID: %) doit être de type Club pour être insérée dans la table Club.',
        NEW.ID_Club;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Application du trigger dédié sur la table Club.
CREATE TRIGGER TRG_CHECK_CLUB
	BEFORE INSERT OR UPDATE ON Club
FOR EACH ROW
EXECUTE FUNCTION trg_check_club_type_fn();

-- -----------------------------------------------------------------------------
-- Fonction et Trigger pour la table NATIONAL_TEAM
-- -----------------------------------------------------------------------------
-- Fonction dédiée à la validation des insertions dans la table National_Team.
CREATE OR REPLACE FUNCTION trg_check_national_team_type_fn()
RETURNS TRIGGER AS $$
DECLARE
    is_national_type BOOLEAN;
BEGIN
    -- On vérifie dans la table mère que l'ID correspond bien à une équipe de type "National_Team".
    -- La référence à NEW.ID_National_Team est valide car ce trigger ne s'applique qu'à la table National_Team.
    SELECT IS_National_Team
    INTO is_national_type
    FROM Team
    WHERE ID_Team = NEW.ID_National_Team;

    IF is_national_type IS DISTINCT FROM TRUE THEN
        RAISE EXCEPTION 'Erreur : L''équipe (ID: %) doit être de type National_Team pour être insérée dans la table National_Team.',
        NEW.ID_National_Team;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Application du trigger dédié sur la table National_Team.
CREATE TRIGGER TRG_CHECK_National_Team
BEFORE INSERT OR UPDATE ON National_Team
FOR EACH ROW
EXECUTE FUNCTION trg_check_national_team_type_fn();

-- #############################################################################
-- # SECTION 4 : HISTORIQUE DES CONTRATS DES JOUEURS (HISTORIC_PLAYER)         #
-- # ------------------------------------------------------------------------- #
-- # Cette section gère les affectations des joueurs aux équipes et implémente #
-- # des règles de gestion complexes via des triggers.                         #
-- #############################################################################
CREATE TABLE Historic_Player(
    ID_Team INT NOT NULL,
    ID_Player INT NOT NULL,
    Start_Date DATE NOT NULL,
    -- End_Date est NULLable : une valeur NULL signifie que le contrat est actuellement en cours.
    End_Date DATE,
    -- Clé primaire composite, un joueur ne peut avoir qu'un seul contrat avec une équipe donnée.
    CONSTRAINT PK_Historic_Player PRIMARY KEY(ID_Team, ID_Player, Start_Date), -- Start_Date a été ajoutée pour permettre de resigner
    CONSTRAINT FK_Historic_Player FOREIGN KEY(ID_Player) REFERENCES Player(ID_Player),
    CONSTRAINT FK_Historic_Team FOREIGN KEY(ID_Team) REFERENCES Team(ID_Team)
);

-- =============================================================================
-- TRIGGER 4.1 : VÉRIFICATION DE LA NATIONALITÉ POUR LES ÉQUIPES NATIONALES
-- =============================================================================
CREATE OR REPLACE FUNCTION trg_check_Player_Nationality_fn()
RETURNS TRIGGER AS $$
DECLARE
    v_is_national_team BOOLEAN;
    v_team_country VARCHAR(55);
BEGIN
    -- La jointure interne (INNER JOIN) agit comme un filtre : la requête ne retourne de résultat
    -- QUE SI l'équipe est une équipe nationale. 
    SELECT T.IS_National_Team, NT.Country
    INTO v_is_national_team, v_team_country
    FROM Team T
    INNER JOIN National_Team NT ON NT.ID_National_Team = T.ID_Team
    WHERE T.ID_Team = NEW.ID_Team;

    -- La condition "IF v_is_national_team" ne sera vraie que si la requête précédente a trouvé une équipe nationale.
    IF v_is_national_team THEN
        -- On vérifie alors si le joueur possède la citoyenneté requise dans la table Citizenship.
        IF NOT EXISTS (
            SELECT 1
            FROM Citizenship C
            WHERE C.ID_Player = NEW.ID_Player AND C.Citizenship = v_team_country
        ) THEN
            RAISE EXCEPTION 'Le joueur (ID: %) ne peut pas rejoindre l''équipe nationale (ID: %) car il ne possède pas la nationalité requise (%).', NEW.ID_Player, NEW.ID_Team, v_team_country;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_Player_Nationality
BEFORE INSERT OR UPDATE ON Historic_Player
FOR EACH ROW
EXECUTE FUNCTION trg_check_Player_Nationality_fn();

-- =============================================================================
-- TRIGGER 4.2 : CONTRÔLE DES CONTRATS ACTIFS (1 CLUB, 1 ÉQUIPE NATIONALE)
-- =============================================================================
CREATE OR REPLACE FUNCTION trg_check_active_teams_fn()
RETURNS TRIGGER AS $$
DECLARE
    is_new_team_club BOOLEAN;
    active_team_count INT;
BEGIN
    -- Optimisation : si on clôture un contrat (en ajoutant une End_Date), pas besoin de vérifier quoi que ce soit.
    IF NEW.End_Date is NOT NULL THEN
        RETURN NEW;
    END IF;
    
    -- On identifie le type de l'équipe que le joueur essaie de rejoindre.
    SELECT T.IS_Club INTO is_new_team_club
    FROM Team T
    WHERE T.ID_Team=NEW.ID_Team;

    -- Si c'est un club...
    IF is_new_team_club THEN
        -- ...on compte combien d'autres contrats de club sont ACTIFS (End_Date IS NULL) pour ce joueur.
        SELECT COUNT(*) INTO active_team_count
        FROM Historic_Player HP
        INNER JOIN Team T ON T.ID_Team=HP.ID_Team 
        WHERE HP.ID_Player=NEW.ID_Player AND HP.End_Date IS NULL AND T.IS_Club=True;

        -- Si le joueur a déjà un contrat actif dans un club, on bloque la nouvelle insertion.
        IF active_team_count > 0 THEN
            RAISE EXCEPTION 'Le joueur (ID : %) est deja engagé dans un autre club et ne peut pas en rejoindre un autre simultanément.', NEW.ID_Player;
        END IF;
    -- Si c'est une équipe nationale...
    ELSE
        -- ...on fait la même vérification pour les équipes nationales.
        SELECT COUNT(*) INTO active_team_count
        FROM Historic_Player HP
        INNER JOIN Team T ON T.ID_Team=HP.ID_Team 
        WHERE HP.ID_Player=NEW.ID_Player AND HP.End_Date IS NULL AND T.IS_National_Team=True;

        IF active_team_count > 0 THEN
            RAISE EXCEPTION 'Le joueur (ID : %) est deja engagé dans une autre équipe nationale et ne peut pas en rejoindre un autre simultanément.', NEW.ID_Player;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_active_teams
BEFORE INSERT OR UPDATE ON Historic_Player
FOR EACH ROW
EXECUTE FUNCTION trg_check_active_teams_fn();

-- #############################################################################
-- # SECTION 5 : GESTION DES SPONSORS ET DU SPONSORING                         #
-- #############################################################################
-- Modèle de spécialisation Personne/Entreprise pour les sponsors.
Create Table Sponsor(
    ID_Sponsor SERIAL Constraint PK_Sponsor Primary Key,
    City VARCHAR(55) NOT NULL,
    Name VARCHAR(55) NOT NULL,
    IS_Person BOOLEAN NOT NULL,
    IS_Company BOOLEAN NOT NULL,
    CONSTRAINT chk_Person_or_Company CHECK (
        (IS_Person AND NOT IS_Company) OR 
        (NOT IS_Person AND IS_Company)
    )
);

-- Table d'association pour lier un Sponsor à une Équipe.
CREATE TABLE Sponsoring (
    ID_Sponsor INT NOT NULL,
    ID_Team INT NOT NULL,
    Start_Date DATE NOT NULL,
    End_Date DATE, -- NULL signifie que le sponsoring est en cours.
    -- Le type NUMERIC(19, 2) est idéal pour les montants financiers, il évite les erreurs d'arrondi et peut stocker de très grandes valeurs (jusqu'à des milliers de milliards).
    Amount NUMERIC(19, 2) NOT NULL,
    -- Clé primaire composite. L'ajout de Start_Date est crucial : il permet à un sponsor de renouveler son contrat avec la même équipe à différentes périodes.
    CONSTRAINT PK_Sponsoring PRIMARY KEY(ID_Sponsor, ID_Team, Start_Date),
    CONSTRAINT FK_Sponsoring_Sponsor FOREIGN KEY(ID_Sponsor) REFERENCES Sponsor(ID_Sponsor),
    CONSTRAINT FK_Sponsoring_Team FOREIGN KEY(ID_Team) REFERENCES Team(ID_Team),
    -- S'assure que la date de début est bien avant la date de fin.
    CONSTRAINT CHK_Dates CHECK (Start_Date < End_Date)
);


-- #############################################################################
-- # SECTION 6 : GESTION DES MATCHS (GAME) ET DES RÈGLES ASSOCIÉES             #
-- #############################################################################
Create Table Game(
    ID_Game SERIAL Constraint PK_Game Primary Key,
    ID_Competition INT NOT NULL,
    Constraint FK_Game_Competition Foreign Key(ID_Competition) REFERENCES Competition
);

-- Table de liaison qui définit les deux équipes s'affrontant dans un match.
Create Table Game_Teams(
    ID_Game INT NOT NULL,
    ID_Team_1 INT NOT NULL,
    ID_Team_2 INT NOT NULL,
    -- Un match est unique, il ne peut donc apparaître qu'une seule fois.
    Constraint PK_Game_Teams Primary Key(ID_Game),
    CONSTRAINT FK_Game_Teams_Game FOREIGN KEY (ID_Game) REFERENCES Game(ID_Game),
    CONSTRAINT FK_Game_Teams_1 FOREIGN KEY (ID_Team_1) REFERENCES Team(ID_Team),
    CONSTRAINT FK_Game_Teams_2 FOREIGN KEY (ID_Team_2) REFERENCES Team(ID_Team),
    -- Une équipe ne peut logiquement pas jouer contre elle-même.
    CONSTRAINT CHK_Teams_Not_Same CHECK (ID_Team_1 <> ID_Team_2)
);

-- ============================================================================
-- TRIGGER 6.1 : APPLICATION DES RÈGLES DE CONFRONTATION DES ÉQUIPES
-- =============================================================================
-- Ce trigger est le gardien des règles métier pour les matchs.
CREATE OR REPLACE FUNCTION trg_check_game_rules_fn()
RETURNS TRIGGER AS $$
DECLARE
    IS_Competition_League BOOLEAN;
    IS_Team_1_Club BOOLEAN;
    IS_Team_2_Club BOOLEAN;
BEGIN
    -- Étape 1 : Déterminer le type de compétition du match.
    SELECT C.IS_League INTO IS_Competition_League
    FROM Game G
    INNER JOIN Competition C ON G.ID_Competition=C.ID_Competition 
    WHERE G.ID_Game=NEW.ID_Game;

    -- Étape 2 : Déterminer le type de chaque équipe.
    SELECT IS_Club INTO IS_Team_1_Club FROM Team WHERE ID_Team=NEW.ID_Team_1;
    SELECT IS_Club INTO IS_Team_2_Club FROM Team WHERE ID_Team=NEW.ID_Team_2;

    -- Étape 3 : Appliquer la logique de validation.
    -- Si c'est une League...
    IF IS_Competition_League THEN
        -- ... alors les deux équipes DOIVENT être des clubs.
        IF NOT IS_Team_1_Club OR NOT IS_Team_2_Club THEN
            RAISE EXCEPTION 'Conflit Compétition/Équipe : Une compétition de type "League" ne peut opposer que des clubs.';
        END IF;
    -- Sinon (c'est un Championship)...
    ELSE
        -- ... alors les deux équipes DOIVENT être des équipes nationales (donc PAS des clubs).
        IF IS_Team_1_Club OR IS_Team_2_Club THEN
            RAISE EXCEPTION 'Conflit Compétition/Équipe : Une compétition de type "Championship" ne peut opposer que des National Teams.';
        END IF;
    END IF;
    
    -- Cette logique couvre parfaitement la règle "les deux équipes doivent être du même type".
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_game_rules
BEFORE INSERT OR UPDATE ON Game_Teams
FOR EACH ROW EXECUTE FUNCTION trg_check_game_rules_fn();

-- #############################################################################
-- # SECTION 7 : GESTION DES PERFORMANCES DES JOUEURS PAR MATCH                #
-- #############################################################################
-- Table unique pour stocker toutes les statistiques d'un joueur pour un match donné.

CREATE TABLE Player_Game_Stats (
    ID_Game INT NOT NULL,
    ID_Player INT NOT NULL,

    -- On stocke les tirs réussis ("made") ET tentés ("attempted") pour chaque type de tir.
    -- C'est indispensable pour calculer les pourcentages de réussite, comme demandé.
    three_points_made INT NOT NULL DEFAULT 0,
    three_points_attempted INT NOT NULL DEFAULT 0,
    
    two_points_made INT NOT NULL DEFAULT 0,
    two_points_attempted INT NOT NULL DEFAULT 0,

    free_throws_made INT NOT NULL DEFAULT 0,
    free_throws_attempted INT NOT NULL DEFAULT 0,

    -- Autres statistiques clés.
    assists INT NOT NULL DEFAULT 0,
    rebounds INT NOT NULL DEFAULT 0,
    blocks INT NOT NULL DEFAULT 0,
    fouls INT NOT NULL DEFAULT 0,

    -- Clé primaire composite : un joueur n'a qu'une seule ligne de statistiques par match.
    CONSTRAINT PK_Player_Game_Stats PRIMARY KEY (ID_Game, ID_Player),
    CONSTRAINT FK_Stats_Game FOREIGN KEY (ID_Game) REFERENCES Game(ID_Game),
    CONSTRAINT FK_Stats_Player FOREIGN KEY (ID_Player) REFERENCES Player(ID_Player),

    -- Contraintes d'intégrité pour garantir que le nombre de tirs réussis ne peut pas dépasser le nombre de tirs tentés.
    CONSTRAINT CHK_3pts CHECK (three_points_made <= three_points_attempted),
    CONSTRAINT CHK_2pts CHECK (two_points_made <= two_points_attempted),
    CONSTRAINT CHK_ft CHECK (free_throws_made <= free_throws_attempted)
);

-- #############################################################################
-- # SECTION 8 : CRÉATION DES INDEX POUR L'OPTIMISATION DES PERFORMANCES       
-- INDEX SUR LES CLÉS ÉTRANGÈRES (POUR ACCÉLÉRER MASSIVEMENT LES JOINTURES)
-- =============================================================================

-- Pour trouver rapidement les saisons d'une compétition.
CREATE INDEX idx_season_id_competition ON Season (ID_Competition);

-- Pour trouver rapidement la citoyenneté par pays (ex: tous les joueurs français).
CREATE INDEX idx_citizenship_citizenship ON Citizenship (Citizenship);

-- Pour trouver rapidement l'historique d'un joueur 
CREATE INDEX idx_historic_player_id_player ON Historic_Player (ID_Player);

-- Pour trouver rapidement tous les sponsors d'une équipe.
CREATE INDEX idx_sponsoring_id_team ON Sponsoring (ID_Team);

-- Pour trouver rapidement tous les matchs d'une compétition.
CREATE INDEX idx_game_id_competition ON Game (ID_Competition);

-- Pour trouver rapidement tous les matchs auxquels une équipe a participé.
-- Il faut un index sur chaque colonne d'équipe.
CREATE INDEX idx_game_teams_id_team_1 ON Game_Teams (ID_Team_1);
CREATE INDEX idx_game_teams_id_team_2 ON Game_Teams (ID_Team_2);

-- Pour trouver rapidement toutes les statistiques d'un joueur sur l'ensemble de ses matchs.
-- C'est probablement l'index le plus important de toute la base pour l'analyse de performance.
CREATE INDEX idx_player_game_stats_id_player ON Player_Game_Stats (ID_Player);


-- =============================================================================
-- INDEX SUR LES COLONNES DE RECHERCHE FRÉQUENTES (POUR ACCÉLÉRER LES CLAUSES WHERE)
-- =============================================================================

-- Pour rechercher un joueur par son nom.
CREATE INDEX idx_player_name ON Player (Name);

-- Pour rechercher un club par son nom.
CREATE INDEX idx_club_name ON Club (Name);

-- Pour rechercher un sponsor par son nom.
CREATE INDEX idx_sponsor_name ON Sponsor (Name);


-- =============================================================================
-- INDEX PARTIEL (TECHNIQUE AVANCÉE POUR UNE OPTIMISATION SPÉCIFIQUE)
-- =============================================================================

-- Cet index ne référence QUE les lignes où un contrat est ACTIF (End_Date IS NULL).
-- Il est extrêmement rapide et petit, idéal pour la requête fréquente : "Trouver le club actuel d'un joueur".
CREATE INDEX idx_historic_player_active_contract ON Historic_Player (ID_Player) WHERE End_Date IS NULL;

--=============================================================================
-- SECTION 8 : TRIGGER : VÉRIFICATION DE LA PRÉSENCE DU JOUEUR DANS LE MATCH
-- =============================================================================
-- L'objectif est de vérifier que lorsqu'on insère des statistiques pour un joueur 
-- Dans un match donné, ce joueur avait bien un contrat actif avec l'une des
-- deux équipes à la date exacte du match.

--Ajouter la colonne obligatoire Game_Date à la table game
ALTER TABLE game
ADD COLUMN Game_Date DATE NOT NULL;

CREATE OR REPLACE FUNCTION trg_check_player_in_game_fn()
RETURNS TRIGGER AS $$
DECLARE
    v_id_team_1 INT;
    v_id_team_2 INT;
    v_game_date DATE;
    v_contract_count INT;
BEGIN
    -- Étape 1 : Récupérer les deux équipes et la date du match en une seule requête.
    SELECT
        gt.ID_Team_1,
        gt.ID_Team_2,
        g.Game_Date
    INTO
        v_id_team_1,
        v_id_team_2,
        v_game_date
    FROM Game g
    JOIN Game_Teams gt ON g.ID_Game = gt.ID_Game
    WHERE g.ID_Game = NEW.ID_Game;

    -- Étape 2 : Vérifier si le joueur (NEW.ID_Player) avait un contrat actif
    -- avec l'une des deux équipes à la date du match.
    -- Un contrat est "actif" si la date du match est comprise entre
    -- la Start_Date et la End_Date du contrat.
    -- Si End_Date est NULL, le contrat est toujours en cours et donc valide.
    SELECT COUNT(*)
    INTO v_contract_count
    FROM Historic_Player
    WHERE
        ID_Player = NEW.ID_Player
        AND (ID_Team = v_id_team_1 OR ID_Team = v_id_team_2)
        AND Start_Date <= v_game_date
        AND (End_Date >= v_game_date OR End_Date IS NULL);

    -- Étape 3 : Si aucun contrat actif n'est trouvé, refuser l'insertion.
    IF v_contract_count = 0 THEN
        RAISE EXCEPTION 'Le joueur (ID: %) n''avait pas de contrat actif avec l''équipe 1 (ID: %) ou l''équipe 2 (ID: %) à la date du match (%). Impossible d''ajouter les statistiques.',
        NEW.ID_Player, v_id_team_1, v_id_team_2, v_game_date;
    END IF;

    -- Si la vérification passe, l'opération (INSERT ou UPDATE) est autorisée.
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Application du trigger sur la table des statistiques de jeu.
CREATE TRIGGER trg_check_player_in_game
BEFORE INSERT OR UPDATE ON Player_Game_Stats
FOR EACH ROW
EXECUTE FUNCTION trg_check_player_in_game_fn();

-- Ajouter une colonne Stage à la table Game pour spécifier la phase de la compétition.
ALTER TABLE GAME
ADD COLUMN Stage VARCHAR(55);
--Ajouter une contrainte pour garantir la qualité des données.
ALTER TABLE GAME
ADD Constraint CHK_Game_Stage CHECK((Stage IN ('Regular Season', 'Play-in', 'Quarter-final', 'Semi-final', 'Final', 'Group Stage')));

-- #############################################################################
-- # SECTION 9 : GESTION DES PALMARÈS (WINNERS)                                #
-- # --------------------------------------------------------------------------#
-- # Cette table a été crée afin de répondre aux requêtes analytiques sur les   #
-- # vainqueurs des compétitions.                                              #
-- #############################################################################

CREATE Table Competition_Winner (
ID_Competition_Winner SERIAL Constraint PK_Competition_Winner Primary Key,
-- Clé étrangère vers la compétition concernée (ex: 'FIBA World Cup').
ID_Competition INT NOT NULL,
Constraint FK_Competition_Winner Foreign Key(ID_Competition) REFERENCES Competition,
-- Clé étrangère vers la saison. NULL pour les championnats qui n'ont pas de saison.
ID_Season INT,
CONSTRAINT FK_Winner_Season FOREIGN KEY (ID_Season) REFERENCES Season(ID_SEASON),
-- L'année du titre. Indispensable pour les championnats (ex: EuroBasket 2025).
Year INT NOT NULL,
-- La clé étrangère vers l'équipe gagnante.
ID_Team_Winner INT NOT NULL,
CONSTRAINT FK_Winner_Team FOREIGN KEY (ID_Team_Winner) REFERENCES Team(ID_Team),
-- Contrainte d'intégrité : On ne peut pas avoir le même vainqueur pour la même compétition la même année.
CONSTRAINT UK_Winner UNIQUE(ID_Competition, Year)
);

-- =============================================================================
-- TRIGGER 9.1 (Version 2.0) : CONTRÔLE DE COHÉRENCE COMPLET POUR LE VAINQUEUR
-- =============================================================================
-- Ce déclencheur vérifie la cohérence des types, mais
-- aussi que l'équipe déclarée vainqueur a bien participé à la compétition.

CREATE OR REPLACE FUNCTION trg_check_winner_consistency_fn()
RETURNS TRIGGER AS $$
DECLARE
    is_competition_league BOOLEAN;
    is_winner_a_club BOOLEAN;
    v_season_competition_id INT;
    v_season_start_date DATE;
    v_season_end_date DATE;
    participation_count INT := 0;
BEGIN
    -- Étape 1 : Récupérer les informations sur la compétition et l'équipe gagnante.
    SELECT C.IS_League INTO is_competition_league
    FROM Competition C WHERE C.ID_Competition = NEW.ID_Competition;

    SELECT T.IS_Club INTO is_winner_a_club
    FROM Team T WHERE T.ID_Team = NEW.ID_Team_Winner;

    -- Étape 2 : Vérifier la cohérence des types (League/Club, Championship/National_Team).
    IF is_competition_league THEN
        IF NEW.ID_Season IS NULL THEN
            RAISE EXCEPTION 'Incohérence : La compétition % est une League. Un ID_Season doit être fourni.', NEW.ID_Competition;
        END IF;
        IF NOT is_winner_a_club THEN
            RAISE EXCEPTION 'Conflit de type : La compétition % est une League, le vainqueur (Équipe ID %) doit être un Club.', NEW.ID_Competition, NEW.ID_Team_Winner;
        END IF;
    ELSE -- C'est un Championship
        IF NEW.ID_Season IS NOT NULL THEN
            RAISE EXCEPTION 'Incohérence : La compétition % est un Championship. L''ID_Season doit être NULL.', NEW.ID_Competition;
        END IF;
        IF is_winner_a_club THEN
            RAISE EXCEPTION 'Conflit de type : La compétition % est un Championship, le vainqueur (Équipe ID %) doit être une National_Team.', NEW.ID_Competition, NEW.ID_Team_Winner;
        END IF;
    END IF;

    -- Étape 3 : Vérifier la cohérence entre la Saison et la Compétition (si applicable).
    IF NEW.ID_Season IS NOT NULL THEN
        SELECT ID_Competition, Start_Date, End_Date
        INTO v_season_competition_id, v_season_start_date, v_season_end_date
        FROM Season WHERE ID_SEASON = NEW.ID_Season;

        IF v_season_competition_id <> NEW.ID_Competition THEN
            RAISE EXCEPTION 'Conflit de données : La Saison ID % n''appartient pas à la Compétition ID %.', NEW.ID_Season, NEW.ID_Competition;
        END IF;
    END IF;

    -- Étape 4 : VÉRIFICATION DE LA PARTICIPATION HISTORIQUE DE L'ÉQUIPE.
    -- C'est la nouvelle logique qui ferme la faille.
    IF is_competition_league THEN
        -- Pour une League, on cherche un match de l'équipe durant les dates de la saison.
        SELECT COUNT(*)
        INTO participation_count
        FROM Game g
        JOIN Game_Teams gt ON g.ID_Game = gt.ID_Game
        WHERE g.ID_Competition = NEW.ID_Competition
          AND (gt.ID_Team_1 = NEW.ID_Team_Winner OR gt.ID_Team_2 = NEW.ID_Team_Winner)
          AND g.Game_Date BETWEEN v_season_start_date AND v_season_end_date;
    ELSE
        -- Pour un Championship, on cherche un match de l'équipe durant l'année du titre.
        SELECT COUNT(*)
        INTO participation_count
        FROM Game g
        JOIN Game_Teams gt ON g.ID_Game = gt.ID_Game
        WHERE g.ID_Competition = NEW.ID_Competition
          AND (gt.ID_Team_1 = NEW.ID_Team_Winner OR gt.ID_Team_2 = NEW.ID_Team_Winner)
          AND EXTRACT(YEAR FROM g.Game_Date) = NEW.Year;
    END IF;

    -- Si aucun match n'est trouvé, l'insertion est refusée.
    IF participation_count = 0 THEN
        RAISE EXCEPTION 'Validation échouée : L''équipe ID % n''a pas participé à la compétition ID % durant la période requise (Saison ID % / Année %).',
        NEW.ID_Team_Winner, NEW.ID_Competition, NEW.ID_Season, NEW.Year;
    END IF;

    -- Si toutes les vérifications sont passées, l'opération est autorisée.
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Pas besoin de recréer le trigger si vous avez juste fait un CREATE OR REPLACE FUNCTION.
-- Sinon, ré-exécutez cette ligne :
CREATE TRIGGER trg_check_winner_consistency
BEFORE INSERT OR UPDATE ON Competition_Winner
FOR EACH ROW
EXECUTE FUNCTION trg_check_winner_consistency_fn();








